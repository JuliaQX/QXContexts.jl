```@meta
CurrentModule = QXContexts
```

# QXContexts

QXContexts is a Julia package for simulating quantum circuits using tensor networking approaches targeting large distributed memory clusters with hardware
accelerators. It was developed as part of the QuantEx project, one of the individual software projects of WP8 of PRACE 6IP.

QXContexts is one of a family of packages each with a different aim. QXContexts is the package that is designed to the do the bulk of the computations and makes use of
distributed compute resources via [MPI.jl](https://github.com/JuliaParallel/MPI.jl) as well as hardware accelerators. [OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl) and [TensorOperations.jl](https://github.com/Jutho/TensorOperations.jl) are currently used to carry out the tensor contractions.

# Installation

QXContexts is a Julia package and can be installed using Julia's inbuilt package manager from the Julia REPL using.

```
import Pkg
Pkg.add("QXContexts")
```

or directly from the github repository with

```
import Pkg
Pkg.add(url="https://github.com/JuliaQX/QXContexts.jl")
```

# Example usage

QXContexts uses input files generated by QXSim which describe the computation to be performed. An example of the input files for a five qubit GHZ circuit are provided
in the `examples/ghz` folder.
This example can be run directly using the `examples/ghz_example.jl` script or this can be run using the CLI `bin/qxrun.jl` script with the following command

```
julia --project bin/qxrun.jl -d examples/ghz/ghz_5.qx -i examples/ghz/ghz_5.jld2 -p examples/ghz/ghz_5.yml -o examples/ghz/out.jld2
```

where the `-d`, `-i` and `-p` switches describe the DSL file, input data file and parameter file to use respectively. The `-o` switch refers to the output file. If all three files have the same prefix, then it is only necessary to provide the name of the dsl file so the example could also be run with the command

```
julia --project bin/qxrun.jl -d examples/ghz/ghz_5.qx -o examples/ghz/out.jld2
```

## Enable timing

To get timing information on the different sections of the code the code has been instrumented with [TimerOutputs.jl](https://github.com/KristofferC/TimerOutputs.jl). To enable this one can set the `QXRUN_TIMER` variable to `1`. For example

```
QXRUN_TIMER=1 julia --project bin/qxrun.jl -d examples/ghz/ghz_5.qx -o examples/ghz/out.jld2
```

## Enable debugging

To get detailed debugging information one can include the package name in the `JULIA_DEBUG` environment variable. For example

```
JULIA_DEBUG=QXContexts julia --project bin/qxrun.jl -d examples/ghz/ghz_5.qx -o examples/ghz/out.jld2
```

This generates very verbose output so care should be taking when using this for large runs.

## Enable logging

To log debug and and performance information to files QXContexts has 3 logger-models:

- QXLogger: the default stdout logger: useful for single node, single process logging (interactive)
- QXLoggerMPIShared: an MPI-IO shared-file logger: all MPI ranks share a single file for writing their respective logs; blocking.
- QXLoggerMPIPerRank: MPI-enabled file per rank logger: non-blocking debug files created per MPI rank.

The loggers can be (individually) instantiated by selecting the global logger to use with one of the following:

```
global_logger(QXContexts.Logger.QXLogger())
global_logger(QXContexts.Logger.QXLoggerMPIShared())
global_logger(QXContexts.Logger.QXLoggerMPIPerRank())
```

# Running with MPI

MPI is used to use multiple processes for computation. The `mpiexecjl` script can be used to launch julia on multiple processes. See [MPI.jl documentation](https://juliaparallel.github.io/MPI.jl/latest/configuration/#Julia-wrapper-for-mpiexec) for details on how to set this up. For example to run the above example with 4 processes one would use the following:

```
mpiexecjl --project -n 4 julia --project bin/qxrun.jl -d examples/ghz/ghz_5.qx -o examples/ghz/out.jld2
```

# Building a sysimg using PackageCompiler.jl

To minimise the JIT compilation overhead associated with different tensor contraction paths, it is possible to generate a Julia sysimg with a large number of contraction operations precompiled. See [PackageCompiler.jl documentation]() for further details on package compilation.

To generate a sysimg, we run the following script:

```bash
julia --project=. bin/sysimg.jl
```

which will output a dynamic library to be loaded for use with QXRun.jl calls. The sysimg name will be built as `QXRun_<Julia version>_<CPU arch>.<system dynamic library extension>`. For example, on a Skylake AVX512 system running Linux and using Julia 1.6, we generate and use the following:

```bash
mpiexecjl --project -n 1 julia -J QXRun_JL1.6.0_skylake-AVX512.so ./examples/rqc_example.jl
```

As we build MPI support into the sysimg, it is important to launch the runtime using the `mpiexecjl` command described earlier.
# Contributing
Contributions from users are welcome and we encourage users to open issues and submit merge/pull requests for any problems or feature requests they have. The
CONTRIBUTING.md on the top level of the source folder has further details of the contribution guidelines.
